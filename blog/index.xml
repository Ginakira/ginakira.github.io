<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on Ginakira's Blog</title><link>https://ginakira.github.io/blog/</link><description>Recent content in Blogs on Ginakira's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Wed, 28 Jun 2023 01:44:00 +0800</lastBuildDate><atom:link href="https://ginakira.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>(译) C++20协程教程与我的个人见解</title><link>https://ginakira.github.io/blog/zh/2023-06-translate-my-tutorial-and-take-on-c++20-coroutines/</link><pubDate>Wed, 28 Jun 2023 01:44:00 +0800</pubDate><guid>https://ginakira.github.io/blog/zh/2023-06-translate-my-tutorial-and-take-on-c++20-coroutines/</guid><description>原文链接：https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html
转载请注明出处，本篇译文遵守 CC-BY-ND 4.0协议，原文协议未知。
引言 在过去的25年里，我用C++编写了很多事件驱动的代码。事件驱动的代码的一个典型示例是注册一个回调函数，每当套接字有数据可读时就会调用该回调函数。 一旦你读取完整个消息，可能经过多次调用，你会解析该消息并从更高层次的抽象中调用另一个回调函数，以此类推。 编写这种代码很痛苦，因为你必须将代码拆分为许多不同的函数，而这些函数由于是不同的函数，所以不共享局部变量。
WIP</description></item><item><title>Hello, world.</title><link>https://ginakira.github.io/blog/zh/hello/</link><pubDate>Sun, 25 Sep 2022 23:15:05 +0800</pubDate><guid>https://ginakira.github.io/blog/zh/hello/</guid><description>Hi.</description></item></channel></rss>